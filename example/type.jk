# The main concept of the type system of Jack is that
# a type is a set of values.

# alias

Vector a = (a, a, a) # This (,,) is a type constructor
Cry = String

# these are not variants!
Edible = Vegetable | Fruit
Maybe a = None | a # none : None (in Jack) ~ () : () (in Haskell)


# enum

# enum is the only way to define a new type
Season = { Spring, Summer, Fall, Winter }
None = { None }
Bool = { False, True }
# Number = { ..., -1.2, .., 0, ..., 0.000001, ..., 12934710, ... }


# record

Vegetable = name : String
Fruit = name : String # override a record name

# This `Pet` is just a record type of:
# {
#   name : Pet -> String,
#   ... ,
#   run : Pet -> Pet,
#   stroked : Pet -> Cry
#   show : Pet -> String
# }
Pet = name : String,
      height : Real,
      favoriteToy : String
  # methods
  run : Pet -> Pet
  run self = self ( favoriteToy = "boots" )

  stroked : Pet -> Cry
  stroked self = if height self < 200
                 then "Don't do that!"
                 else "You can't do that..."

  # implement Show interface
  show : Pet -> String
  show self = name self ++ " likes " ++ favoriteToy self

# constructing pets
myPet = Pet "John" 60 "ball"
yourPet = Pet ( name = "Bob", height = 30, favoriteToy = "you" )


# interface

# An "interface" is an abstract base class in OOP.
# It consists of prototypes of its methods.
interface Show # NOT `Show a`!
  show : Show -> String
  # for example
  # show _ = "THE CLASS NAME"

interface Monad a
  return : a -> Monad a
  bind : Monad a -> (a -> Monad b) -> Monad b

Identity a = runIdentity : a
  # just override methods to implement an interface
  return a = Identity a
  bind x f = (f . runIdentity) x
